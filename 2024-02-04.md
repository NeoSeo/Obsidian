
# SQL Analytic

Using windows function, a table doesn't eliminate row levels unlike group by but we could aggregate or analyse the table by creating columns

## clause with rows / range clause
- UNBOUNDED PRECEDING – All rows before the current row.
- n PRECEDING – n rows before the current row.
- CURRENT ROW – Just the current row.
- n FOLLOWING – n rows after the current row.
- UNBOUNDED FOLLOWING – All rows after the current row.

![[Example of range.png]]
## What if the second and the third are same.. 
- rank() over --- 1,2,2,4.... 
- dense_rank() over ---- 1,2,2,3....
- row_number() over ---- 1,2,3,4,....
Pleaes note window functions are not used for these clause. It doesn't required
## Null value processing
``` sql
rank() over (partition by deptno order by sal nulls last) -- basicially nulls first is default (showing null value as priorities)
```

## Analytic sql, Sum()
``` sql

select *
	   , sum(amount) over (partition by order_id) as total
	   , sum(amount) over (partition by order_id order by line_prod_seq) as cum_sum -- order by pros enables sum function to cumulate aggregation here
	   , sum(amount) over (partition by order_id order by line_prod_seq rows between unbounded preceding and current row) as cum_sum_2 -- same as previous clause, but if we change 1 preceding, it will aggregate from -1 row data to current row
	   , sum(amount) over () as total_2 -- aggregate all of amounts in the table	
from nw.order_items

```
When there is  order by clause, default window clause is 'range unbounded preceding and current row'

